# generated by datamodel-codegen:
#   filename:  tmp_dv03s1k_schema.json
#   timestamp: 2025-07-04T08:40:07+00:00

from __future__ import annotations

from enum import Enum
from typing import List, Optional

from pydantic import BaseModel, Field


class ContinentEnum(Enum):
    Europe = 'Europe'
    Asia = 'Asia'


class CountryEnum(Enum):
    el = 'el'
    it = 'it'
    fr = 'fr'
    nl = 'nl'
    ie = 'ie'
    pt = 'pt'
    dk = 'dk'
    il = 'il'


class CityEnum(Enum):
    volos = 'volos'
    athens = 'athens'
    rende = 'rende'
    milan = 'milan'
    lille = 'lille'
    delft = 'delft'
    dublin = 'dublin'
    aveiro = 'aveiro'
    porto = 'porto'
    aarhus = 'aarhus'
    jerusalem = 'jerusalem'


class Location(BaseModel):
    continent: Optional[List[ContinentEnum]] = None
    country: Optional[List[CountryEnum]] = Field(
        None, description='The required country (optional)'
    )
    city: Optional[List[CityEnum]] = None


class CloudProvider(Enum):
    private = 'private'
    aws = 'aws'
    microsoft_azure = 'microsoft_azure'
    gcp = 'gcp'


class Accelerator(Enum):
    gpu = 'gpu'
    fpga = 'fpga'
    tpu = 'tpu'


class NodeType(Enum):
    cloud = 'cloud'
    far_edge = 'far_edge'
    edge_infrastructure = 'edge_infrastructure'
    edge = 'edge'


class ClusterPlacement(BaseModel):
    cluster_id: Optional[List[str]] = Field(
        None, description='Array of clusters that can host the application.'
    )
    instances: Optional[int] = Field(
        None,
        description='The desired number of replicas (e.g. deploy 2 instances of a given app).',
    )
    location: Optional[Location] = None
    cloud_provider: Optional[CloudProvider] = None
    accelerators: Optional[List[Accelerator]] = Field(
        None,
        description='The candidate clusters should have nodes containing at least one instance of the specified accelerators.',
    )
    node_types: Optional[List[NodeType]] = Field(
        None,
        description='The candidate clusters should contain at least one node of each specified type.',
    )


class ContinuumLayerEnum(Enum):
    cloud = 'cloud'
    far_edge = 'far_edge'
    edge_infrastructure = 'edge_infrastructure'
    edge = 'edge'
    field_ = '*'


class ScalingMode(Enum):
    manual = 'manual'
    auto = 'auto'


class ScalingCriteria(Enum):
    min_cpu_utilization = 'min_cpu_utilization'
    max_cpu_utilization = 'max_cpu_utilization'
    min_memory_percent = 'min_memory_percent'
    max_memory_percent = 'max_memory_percent'
    min_requests_per_sec = 'min_requests_per_sec'
    max_request_per_sec = 'max_request_per_sec'
    min_number_of_instances = 'min_number_of_instances'
    max_number_of_instances = 'max_number_of_instances'


class Scaling(BaseModel):
    scaling_mode: Optional[ScalingMode] = None
    instances: Optional[int] = Field(
        None,
        description='In case of manual scaling of the component, specify the number of instances.',
    )
    scaling_criteria: Optional[ScalingCriteria] = Field(
        None,
        description='Scaling criteria for the component, related to the "auto" scaling type.',
    )


class SingleNodeItem(BaseModel):
    components: Optional[List[str]] = Field(
        None, description='The array of components to be deployed on the same Node.'
    )
    continuum_layer: Optional[List[ContinuumLayerEnum]] = None
    scaling: Optional[Scaling] = Field(
        None, description='The component scaling information.'
    )
    mobile: Optional[bool] = Field(
        None,
        description='Specify if the component must be deployed on a mobile node (optional)',
    )
    labels: Optional[List[str]] = Field(
        None, description='The required labels for filtering.'
    )
    node: Optional[str] = Field(
        None,
        description='The required node name to be the host of the component (optional).',
    )


class Metadata(BaseModel):
    name: Optional[str] = Field(None, description='The unique name of the component')
    uid: Optional[str] = Field(
        None,
        description='The unique identifier of the component (not given by app provider).',
    )


class Scaling1(BaseModel):
    scaling_mode: Optional[ScalingMode] = None
    instances: Optional[int] = Field(
        None,
        description='In case of manual scaling of the component, specify the number of instances.',
    )
    scaling_criteria: Optional[ScalingCriteria] = Field(
        None,
        description='Scaling criteria for the component, related to the "auto" scaling type.',
    )


class NodePlacement(BaseModel):
    continuum_layer: Optional[List[ContinuumLayerEnum]] = None
    scaling: Optional[Scaling1] = Field(
        None, description='The component scaling information.'
    )
    mobile: Optional[bool] = Field(
        None,
        description='Specify if the component needs to be deployed on a mobile node (optional)',
    )
    labels: Optional[List[str]] = Field(
        None, description='The required labels for filtering.'
    )
    node: Optional[str] = Field(
        None,
        description='The required node name to be the host of the component (optional).',
    )


class RuntimeConfiguration(BaseModel):
    config_specification_file: Optional[str] = Field(
        None,
        description='The actual specification file describing the available runtime configuration knobs (expected in json format). This file is provided by the app developer.',
    )
    config_file_path: Optional[str] = Field(
        None,
        description='The absolute path inside the container where the application code expects to find the configSpecificationFile.',
    )


class Model(Enum):
    d455 = 'd455'
    imx477 = 'imx477'
    picamera_v2 = 'picamera-v2'


class CameraType(Enum):
    rgb = 'rgb'
    nir = 'nir'
    thermal = 'thermal'
    monocular = 'monocular'


class Resolution(Enum):
    field_1024x768 = '1024x768'
    field_4056x3040 = '4056x3040'


class Camera(BaseModel):
    model: Optional[Model] = Field(
        None, description='The model name of the camera sensor'
    )
    camera_type: Optional[CameraType] = Field(
        None, description='The camera sensor type.'
    )
    minimum_framerate: Optional[int] = None
    resolution: Optional[Resolution] = None


class Model1(Enum):
    sdc30 = 'sdc30'
    ds18b20 = 'ds18b20'


class MeasurementUnit(Enum):
    celsius = 'celsius'
    fahrenheit = 'fahrenheit'


class Temperature(BaseModel):
    model: Optional[Model1] = Field(
        None, description='The model name of the temperature sensor'
    )
    measurement_min: Optional[float] = None
    measurement_max: Optional[float] = None
    measurement_unit: Optional[MeasurementUnit] = None
    accuracy: Optional[float] = None
    sampling_frequency: Optional[float] = None


class Model2(Enum):
    field_3038_smt = '3038-smt'


class MeasurementUnit1(Enum):
    m_s_2 = 'm/s^2'


class Accelerometer(BaseModel):
    model: Optional[Model2] = None
    measurement_min: Optional[float] = None
    measurement_max: Optional[float] = None
    measurement_unit: Optional[MeasurementUnit1] = None
    accuracy: Optional[float] = None
    sampling_frequency: Optional[float] = None


class Model3(Enum):
    sb_100 = 'sb-100'


class MeasurementUnit2(Enum):
    pa = 'pa'


class Barometer(BaseModel):
    model: Optional[Model3] = None
    measurement_min: Optional[float] = None
    measurement_max: Optional[float] = None
    measurement_unit: Optional[MeasurementUnit2] = None
    accuracy: Optional[float] = None
    sampling_frequency: Optional[float] = None


class Model4(Enum):
    mq_135 = 'mq-135'


class MeasurementUnit3(Enum):
    ug_m_3 = 'ug/m^3'


class AirQuality(BaseModel):
    model: Optional[Model4] = None
    measurement_min: Optional[float] = None
    measurement_max: Optional[float] = None
    measurement_unit: Optional[MeasurementUnit3] = None
    accuracy: Optional[float] = None
    sampling_frequency: Optional[float] = None


class Protocol(Enum):
    MQTT = 'MQTT'
    RTSP = 'RTSP'


class Sensor(BaseModel):
    camera: Optional[Camera] = None
    temperature: Optional[Temperature] = None
    accelerometer: Optional[Accelerometer] = None
    barometer: Optional[Barometer] = None
    air_quality: Optional[AirQuality] = None
    endpoint_variable: Optional[str] = Field(
        None,
        description='The env variable that the app will retrieve the endpoint to get the sensor measurements.',
    )
    protocol: Optional[Protocol] = Field(
        None, description='The protocol of the sensor service.'
    )
    instances: Optional[float] = Field(
        None, description='The number of required sensor instances.'
    )


class Relation(Enum):
    lower_or_equal = 'lower_or_equal'
    greater_or_equal = 'greater_or_equal'
    equal = 'equal'
    lower_than = 'lower_than'
    greater_than = 'greater_than'


class SystemMetricsHint(Enum):
    cpu_frequency = 'cpu_frequency'


class QosMetric(BaseModel):
    application_metric_id: Optional[str] = Field(
        None,
        description='This is an indicative list of metrics. It can be extended as needed.',
    )
    target: Optional[float] = None
    relation: Optional[Relation] = None
    system_metrics_hints: Optional[List[SystemMetricsHint]] = Field(
        None, description='System-level metrics affecting the application metric.'
    )


class LocationRestrictions(BaseModel):
    gdpr: Optional[bool] = Field(
        None,
        description='For EU citizens only GDPR-compliant storage locations can legally be used.',
    )


class Reduncancy(Enum):
    high = 'high'
    one = 'one'
    none = 'none'


class ServerSideEncryption(Enum):
    True_ = True
    False_ = False


class Bucket(BaseModel):
    bucket_id: str = Field(..., description="The bucket's unique identifier.")
    policy_update_token: Optional[str] = Field(
        None,
        description="The required token for the MLSysOps to update the bucket's policy at runtime.",
    )
    location_restrictions: Optional[LocationRestrictions] = Field(
        None,
        description='These restrictions are used to exclude storage locations that host data of the application.',
    )
    reduncancy: Optional[Reduncancy] = None
    max_latency: Optional[float] = None
    min_download_speed: Optional[float] = None
    server_side_encryption: Optional[ServerSideEncryption] = None


class Storage(BaseModel):
    buckets: Optional[List[Bucket]] = None


class DataCriticality(Enum):
    low = 'low'
    medium = 'medium'
    high = 'high'


class RuntimeClassName(Enum):
    nvidia = 'nvidia'
    default = 'default'
    kata_fc = 'kata-fc'
    kata_dragon = 'kata-dragon'
    urunc = 'urunc'
    crun = 'crun'
    lunatic = 'lunatic'
    nvidia_experimental = 'nvidia-experimental'
    spin = 'spin'
    wasmedge = 'wasmedge'
    slight = 'slight'


class RestartPolicy(Enum):
    Always = 'Always'
    OnFailure = 'OnFailure'
    Never = 'Never'


class Os(Enum):
    ubuntu = 'ubuntu'
    kali = 'kali'
    zephyr = 'zephyr'


class NodeType1(Enum):
    virtualized = 'virtualized'
    native = 'native'
    bare_metal = 'bare_metal'


class ContainerRuntime(Enum):
    containerd = 'containerd'
    docker = 'docker'
    emb_serve = 'emb_serve'


class ImagePullPolicy(Enum):
    Always = 'Always'
    Never = 'Never'
    IfNotPresent = 'IfNotPresent'


class CallName(Enum):
    calc_optical_flow = 'calc_optical_flow'
    image_inference = 'image_inference'


class RequiredFramework(Enum):
    pytorch = 'pytorch'
    tensorflow = 'tensorflow'
    opencl = 'opencl'
    field_ = '*'


class AccelerationApiItem(BaseModel):
    call_name: CallName = Field(..., description='The (unique) API call name.')
    required_framework: Optional[RequiredFramework] = Field(
        None, description='Asterisk means any of the available frameworks.'
    )


class ArchitectureEnum(Enum):
    arm64 = 'arm64'
    amd64 = 'amd64'


class Cpu(BaseModel):
    requests: Optional[str] = None
    limits: Optional[str] = None
    architecture: Optional[List[ArchitectureEnum]] = None
    frequency: Optional[float] = Field(None, description='required frequency in Hz.')
    performance_indicator: Optional[float] = Field(
        None,
        description='This field assists MLSysOps with an initial hint in order to filter out nodes based on their performance capabilities.',
    )


class Memory(BaseModel):
    requests: Optional[str] = None
    limits: Optional[str] = None


class ArchitectureEnum1(Enum):
    arm_m4 = 'arm-m4'


class Mcu(BaseModel):
    requests: Optional[str] = None
    limits: Optional[str] = None
    architecture: Optional[List[ArchitectureEnum1]] = None
    flash: Optional[str] = Field(
        None, description='Flash memory size (related to far edge devices)'
    )
    frequency: Optional[float] = Field(None, description='required frequency in GHz.')
    performance_indicator: Optional[float] = Field(
        None,
        description='This field assists MLSysOps with an initial hint in order to filter out nodes based on their performance capabilities.',
    )


class Model5(Enum):
    k80 = 'k80'
    k40 = 'k40'


class Gpu(BaseModel):
    requests: Optional[int] = None
    limits: Optional[int] = None
    model: Optional[Model5] = None
    memory: Optional[int] = None
    utilization_request: Optional[str] = Field(
        None, description='Percentage of expected utilization.'
    )
    performance_indicator: Optional[float] = Field(
        None,
        description='This field assists MLSysOps with an initial hint in order to filter out nodes based on their performance capabilities.',
    )


class Model6(Enum):
    zcu102 = 'zcu102'


class Fpga(BaseModel):
    model: Optional[Model6] = None
    memory: Optional[int] = None
    utilization_request: Optional[str] = Field(
        None, description='Percentage of expected utilization.'
    )
    performance_indicator: Optional[float] = Field(
        None,
        description='This field assists MLSysOps with an initial hint in order to filter out nodes based on their performance capabilities.',
    )


class PlatformRequirements(BaseModel):
    cpu: Optional[Cpu] = None
    memory: Optional[Memory] = None
    mcu: Optional[Mcu] = None
    disk: Optional[str] = Field(None, description='required Disk space (in GB).')
    gpu: Optional[Gpu] = None
    fpga: Optional[Fpga] = None


class Protocol1(Enum):
    UDP = 'UDP'
    TCP = 'TCP'
    SCTP = 'SCTP'


class Port(BaseModel):
    container_port: Optional[int] = Field(
        None,
        description="Number of port to expose on the component's IP address. This must be a valid port number, 0 < x < 65536.",
    )
    host_ip: Optional[str] = Field(
        None, description='What host IP to bind the external port to.'
    )
    host_port: Optional[int] = Field(
        None,
        description='Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort.',
    )
    name: Optional[str] = Field(
        None,
        description='Each named port in a component must have a unique name. Name for the port that can be referred to by services.',
    )
    protocol: Optional[Protocol1] = Field(
        None, description='Protocol for port. Defaults to "TCP".'
    )


class FieldRef(BaseModel):
    field_path: Optional[str] = None


class ValueFrom(BaseModel):
    field_ref: Optional[FieldRef] = None


class EnvItem(BaseModel):
    name: Optional[str] = Field(None, description='Name of the environment variable.')
    value_from: Optional[ValueFrom] = None
    value: Optional[str] = Field(None, description='Value of the environment variable.')


class Container(BaseModel):
    image: Optional[str] = Field(None, description='The name of the container image.')
    command: Optional[List[str]] = None
    image_pull_policy: Optional[ImagePullPolicy] = Field(
        None,
        description='Image pull policy. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.',
    )
    acceleration_api: Optional[List[AccelerationApiItem]] = None
    platform_requirements: Optional[PlatformRequirements] = Field(
        None, description='The resource requirements of the container.'
    )
    ports: Optional[List[Port]] = Field(
        None, description='Environment variables for the container.'
    )
    env: Optional[List[EnvItem]] = Field(
        None, description='Environment variables for the container.'
    )


class Component(BaseModel):
    metadata: Metadata
    node_placement: Optional[NodePlacement] = None
    depends_on: Optional[List[str]] = Field(
        None,
        description='The given component should be deployed after all the components specified in the Components list have already started running.',
    )
    runtime_configuration: Optional[RuntimeConfiguration] = Field(
        None,
        description='Enables runtime (node-level) configuration for app components.',
    )
    sensors: Optional[List[Sensor]] = None
    qos_metrics: Optional[List[QosMetric]] = None
    storage: Optional[Storage] = None
    data_sensitivity: Optional[bool] = Field(
        None,
        description='The indication to specify whether a component has sensitive data or not (useful for the data storage).',
    )
    data_criticality: Optional[DataCriticality] = Field(
        None,
        description='Used to provide information referring to the trust aspect for a given component.',
    )
    external_component: Optional[bool] = Field(
        None,
        description='This property indicates whether the component can be managed by MLSysOps or not. If not the MLSysOps platform merely deploys the component(s), based on the provided instances, and subsequently deletes it whenever the application needs to be removed.',
    )
    external_access: Optional[bool] = Field(
        None,
        description='This property indicates whether the component can be accessed outside of its cluster.',
    )
    host_network: Optional[bool] = Field(
        None,
        description="Host networking requested for this component. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.",
    )
    runtime_class_name: Optional[RuntimeClassName] = None
    restart_policy: Optional[RestartPolicy] = Field(
        None, description='Restart policy for the container. Default to Always.'
    )
    os: Optional[Os] = None
    node_type: Optional[NodeType1] = None
    container_runtime: Optional[ContainerRuntime] = None
    containers: List[Container]


class Type(Enum):
    ingress = 'ingress'
    egress = 'egress'


class InteractionCriticality(Enum):
    low = 'low'
    medium = 'medium'
    high = 'high'


class SystemMetricId(Enum):
    latency = 'latency'
    bandwidth = 'bandwidth'
    end_to_end_invocation_delay = 'end_to_end_invocation_delay'


class MeasurementUnit4(Enum):
    milliseconds = 'milliseconds'
    Mbps = 'Mbps'
    seconds = 'seconds'


class InteractionMetric(BaseModel):
    system_metric_id: Optional[SystemMetricId] = Field(
        None,
        description='The unique identifier of the system-level metric related to this interaction.',
    )
    target: Optional[float] = None
    measurement_unit: Optional[MeasurementUnit4] = None
    relation: Optional[Relation] = None


class ComponentInteraction(BaseModel):
    component_name1: Optional[str] = Field(None, description='The "source" component.')
    type: Optional[Type] = None
    component_name2: Optional[str] = Field(
        None, description='The "destination" component.'
    )
    interaction_criticality: Optional[InteractionCriticality] = Field(
        None,
        description='Used to provide information referring to the trust aspect for a given interaction.',
    )
    interaction_metrics: Optional[List[InteractionMetric]] = None


class PermittedAction(Enum):
    component_relocation = 'component_relocation'
    traffic_redirection = 'traffic_redirection'
    change_container_image = 'change_container_image'
    change_container_runtime_class = 'change_container_runtime_class'
    change_container_cpu_set = 'change_container_cpu_set'
    change_container_resource_requirements = 'change_container_resource_requirements'
    acceleration = 'acceleration'
    field_ = '*'


class Relation2(Enum):
    greater_or_equal = 'greater_or_equal'
    equal = 'equal'
    greater_than = 'greater_than'


class AchievementWeight(BaseModel):
    metric_id: Optional[str] = None
    weight: Optional[float] = None


class GlobalSatisfaction(BaseModel):
    threshold: Optional[float] = Field(
        None, description='Happiness minimum required value (range (0-1])'
    )
    relation: Optional[Relation2] = None
    achievement_weights: Optional[List[AchievementWeight]] = None


class MLSysOpsApp(BaseModel):
    name: Optional[str] = None
    cluster_placement: Optional[ClusterPlacement] = None
    single_node: Optional[List[SingleNodeItem]] = None
    components: List[Component]
    component_interactions: Optional[List[ComponentInteraction]] = None
    permitted_actions: Optional[List[PermittedAction]] = Field(
        None,
        description='List of desired actions that can be performed by the MLSysOps agents. For traffic redirection, it must be enabled in the respective node description in order for MLSysOps to apply it.',
    )
    global_satisfaction: Optional[GlobalSatisfaction] = None


class MlsysopsappSchema(BaseModel):
    MLSysOpsApp: MLSysOpsApp
