#  Copyright (c) 2025. MLSysOps Consortium
#  #
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#  #
#      http://www.apache.org/licenses/LICENSE-2.0
#  #
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
#

import asyncio
import os
import time
import traceback
from glob import glob

import kubernetes.client.rest

from mlsysops.agent import MLSAgent
from mlsysops.events import MessageEvents
from mlsysops.logger_util import logger

from kubernetes_asyncio.client.rest import ApiException
import kubernetes_asyncio
from kubernetes_asyncio import config, client
from kubernetes import client, config

from jinja2 import Environment, FileSystemLoader  # Add Jinja2 import for template rendering
from ruamel.yaml import YAML  # YAML parser for handling PropagationPolicy definitions

import os
import traceback
from glob import glob
from jinja2 import Environment, FileSystemLoader
from kubernetes import client, config
from ruamel.yaml import YAML
from mlsysops.logger_util import logger

from kubernetes_library import KubernetesLibrary

class MLSContinuumAgent(MLSAgent):

    def __init__(self):
        # Deploy essential services
        self.apply_deployments("./templates/essential_deployments",os.getenv("HOST_IP"))

        logger.debug("Starting MLSContinuumAgent process...")

        # Wait for other services to start
        time.sleep(1) # TODO change this to dynamic discover?

        # Initialize base MLS agent class
        super().__init__()

        # Application
        self.active_components = {}  # Dictionary to track active application MLSComponent
        self.clusters = {}
        self.directory = "descriptions"
        # Kubeconfigs - the default communicates with the Karmada host cluster, and second is the Karmada API
        # need to have the karmada api as a file
        self.karmada_api_kubeconfig = os.getenv("KARMADA_API_KUBECONFIG", "/etc/mlsysops/kubeconfigs/karmada-api.kubeconfig")
        self.yaml_parser = YAML(typ='safe')

    async def run(self):
        """
        Main process of the MLSAgent.
        """
        await super().run()

        logger.info("Starting MLSAgent process...")
        self.clusters = await self.get_karmada_clusters()

        logger.info("Applying propagation policies...")
        await self.apply_propagation_policies()
        logger.info("Applying Namespaces...")
        await self.apply_namespace_to_karmada("templates/agents/namespace.yaml")
        logger.info("Applying RBAC...")
        await self.apply_rbac_to_karmada("templates/agents/mlsysops.rbac.yaml")
        logger.info("Applying CRDs...")
        await self.ensure_crds()
        
        # Fetch cluster description and deploy agents
        logger.info("Applying cluster description...")
        await self.apply_system_description()


        # Start the message queue listener task
        message_queue_task = asyncio.create_task(self.message_queue_listener())
        self.running_tasks.append(message_queue_task)

        try:
            results = await asyncio.gather(*self.running_tasks, return_exceptions=True)
            for result in results:
                if isinstance(result, Exception):
                    logger.error(f"Task raised an exception: {result}")
        except Exception as e:
            logger.error(f"Error in running tasks: {e}")

        print("MLSAgent stopped.")

    async def message_queue_listener(self):
        """
        Task to listen for messages from the message queue and act upon them.
        """
        logger.info("Starting Message Queue Listener...")
        while True:
            try:
                # Wait for a message from the queue
                message = await self.message_queue.get()
                print(f"Received message: {message}")

                # Extract event type and application details from the message
                event = message.get("event")  # Expected event field
                data = message.get("payload")  # Additional application-specific data
                # Act upon the event type
                if event == MessageEvents.APP_SUBMIT.value:
                    await self.application_controller.on_application_received(data)
                if event == MessageEvents.APP_REMOVED.value:
                    await self.application_controller.on_application_removed(data)
                else:
                    print(f"Unhandled event type: {event}")

            except Exception as e:
                print(f"Error processing message: {e}")

    async def apply_propagation_policies(self):
        """
        Dynamically generate and apply a PropagationPolicy using the active clusters from self.clusters.
        """
        try:
            # Extract cluster names where the cluster status is True (ready)
            cluster_names = [name for name, status in self.clusters.items() if status.lower() == 'true']

            logger.debug(f"Applying PropagationPolicy with cluster names: {cluster_names}")

            env = Environment(loader=FileSystemLoader(searchpath="./templates"))  # Load from "templates" dir

            # Apply Cluster-Wide PropagationPolicy
            try:
                name = "mlsysops-applicationcrd-propagation-policy"
                cluster_template = env.get_template("cluster-propagation-policy.yaml")
                rendered_cluster_policy = cluster_template.render(name=name,cluster_names=cluster_names)

                # Parse YAML to Python dictionary
                yaml = YAML(typ='safe')
                cluster_policy_body = yaml.load(rendered_cluster_policy)

                # Apply the Cluster-Wide PropagationPolicy
                await self._apply_policy(
                    policy_name=name,
                    policy_body=cluster_policy_body,
                    plural="clusterpropagationpolicies",
                    namespaced=False,
                )

            except Exception as e:
                logger.error(f"Error applying Cluster-Wide PropagationPolicy: {e}")

            # Apply Simple PropagationPolicy
            try:
                name = "mlsysops-propagate-policy"
                simple_template = env.get_template("application-cr-propagation-policy.yaml")
                rendered_simple_policy = simple_template.render(name=name,cluster_names=cluster_names)

                # Parse YAML to Python dictionary
                yaml = YAML(typ='safe')
                simple_policy_body = yaml.load(rendered_simple_policy)

                # Apply the Simple PropagationPolicy
                await self._apply_policy(
                    policy_name=name,
                    policy_body=simple_policy_body,
                    plural="propagationpolicies",
                    namespaced=True,
                    namespace="default"
                )

            except Exception as e:
                logger.error(f"Error applying Simple PropagationPolicy: {e}")

        except Exception as e:
            logger.error(f"Error applying PropagationPolicies: {e}")

            logger.error(f"Error applying PropagationPolicy: {e}")

    async def _apply_policy(self, policy_name: str, policy_body: dict, plural: str, namespaced: bool = False, namespace: str = None):
        """
        Apply or update a resource in Karmada.

        Handles both namespaced and cluster-scoped resources.

        :param policy_name: The name of the resource (used for identification).
        :param policy_body: The body of the resource as a Python dictionary.
        :param plural: The plural name of the resource (e.g., "propagationpolicies" or "clusterpropagationpolicies").
        :param namespaced: Whether the resource is namespaced (True) or cluster-scoped (False).
        :param namespace: The namespace to target for namespaced resources (required if namespaced=True).
        """
        try:
            # Load the Kubernetes configuration
            await kubernetes_asyncio.config.load_kube_config(config_file=self.karmada_api_kubeconfig)

            async with kubernetes_asyncio.client.ApiClient() as api_client:
                custom_api = kubernetes_asyncio.client.CustomObjectsApi(api_client)

                # Define API group and version (specific to Karmada policies)
                group = "policy.karmada.io"
                version = "v1alpha1"

                logger.debug(
                    f"Applying resource '{policy_name}' with group: {group}, version: {version}, plural: {plural}, namespaced: {namespaced}"
                )

                if namespaced and not namespace:
                    raise ValueError("Namespace must be provided for namespaced resources.")

                try:
                    if namespaced:
                        # Fetch the current resource in the given namespace
                        current_resource = await custom_api.get_namespaced_custom_object(
                            group=group,
                            version=version,
                            namespace=namespace,
                            plural=plural,
                            name=policy_name
                        )
                    else:
                        # Fetch the current cluster-scoped resource
                        current_resource = await custom_api.get_cluster_custom_object(
                            group=group,
                            version=version,
                            plural=plural,
                            name=policy_name
                        )

                    # Add the required resourceVersion field to the policy body
                    resource_version = current_resource["metadata"]["resourceVersion"]
                    policy_body["metadata"]["resourceVersion"] = resource_version

                    logger.info(f"Resource '{policy_name}' exists. Updating it...")

                    # Perform an update using replace
                    if namespaced:
                        await custom_api.replace_namespaced_custom_object(
                            group=group,
                            version=version,
                            namespace=namespace,
                            plural=plural,
                            name=policy_name,
                            body=policy_body
                        )
                    else:
                        await custom_api.replace_cluster_custom_object(
                            group=group,
                            version=version,
                            plural=plural,
                            name=policy_name,
                            body=policy_body
                        )
                    logger.info(f"Resource '{policy_name}' updated successfully.")

                except kubernetes_asyncio.client.exceptions.ApiException as e:
                    if e.status == 404:
                        # If the resource doesn't exist, create a new one
                        logger.info(f"Resource '{policy_name}' not found. Creating a new one...")

                        # Create the new resource
                        if namespaced:
                            await custom_api.create_namespaced_custom_object(
                                group=group,
                                version=version,
                                namespace=namespace,
                                plural=plural,
                                body=policy_body
                            )
                        else:
                            await custom_api.create_cluster_custom_object(
                                group=group,
                                version=version,
                                plural=plural,
                                body=policy_body
                            )
                        logger.info(f"New resource '{policy_name}' created successfully.")
                else:
                    raise  # Re-raise any non-404 exceptions

        except Exception as e:
            logger.error(f"Error applying resource '{policy_name}': {e}")

    async def ensure_crds(self):
        """Ensure all MLSysOps CRDs are registered.

        Checks if the MLSysOps-related resource definitions are registered and
        registers any missing.
        """

        #: the REST API group name
        API_GROUP = 'mlsysops.eu'
        #: System file directory of CRDs
        _CRDS_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), 'templates/'))

        mlsysops_node_dict = {
            'singular': 'mlsysopsnode',
            'plural': 'mlsysopsnodes',
            'kind': 'MLSysOpsNode',
            'crd_name': f'mlsysopsnodes.{API_GROUP}',
            'crd_file': f'{_CRDS_DIR}/MLSysOpsNode.yaml',
            'version': 'v1'
        }

        mlsysops_app_dict = {
            'singular': 'mlsysopsapp',
            'plural': 'mlsysopsapps',
            'kind': 'MLSysOpsApp',
            'crd_name': f'mlsysopsapps.{API_GROUP}',
            'crd_file': f'{_CRDS_DIR}/MLSysOpsApplication.yaml',
            'version': 'v1'
        }

        mlsysops_cont_dict = {
            'singular': 'mlsysopscontinuum',
            'plural': 'mlsysopscontinuums',
            'kind': 'MLSysOpsContinuum',
            'crd_name': f'mlsysopscontinuums.{API_GROUP}',
            'crd_file': f'{_CRDS_DIR}/MLSysOpsContinuum.yaml',
            'version': 'v1'
        }

        mlsysops_cluster_dict = {
            'singular': 'mlsysopscluster',
            'plural': 'mlsysopsclusters',
            'kind': 'MLSysOpsCluster',
            'crd_name': f'mlsysopsclusters.{API_GROUP}',
            'crd_file': f'{_CRDS_DIR}/MLSysOpsCluster.yaml',
            'version': 'v1'
        }

        #: list: List with info regarding the supported custom resources
        CRDS_INFO_LIST = [mlsysops_node_dict, mlsysops_app_dict, mlsysops_cont_dict, mlsysops_cluster_dict]

        # connect to karmada api
        await kubernetes_asyncio.config.load_kube_config(config_file=self.karmada_api_kubeconfig)
        async with kubernetes_asyncio.client.ApiClient() as api_client:
            ext_api = kubernetes_asyncio.client.ApiextensionsV1Api(api_client)
            # Get the list of registered CRD names
            current_crds_response = await ext_api.list_custom_resource_definition()
            current_crds = current_crds_response.to_dict()['items']
            current_crds_names = [x['spec']['names']['singular'] for x in current_crds]

            for crd_info in CRDS_INFO_LIST:
                if crd_info['singular'] in current_crds_names:
                    logger.info('MLSysOps CRD: %s already exists', crd_info['kind'])
                else:
                    logger.info('Creating MLSysOps CRD: %s', crd_info['kind'])
                    try:
                        yaml = YAML(typ='safe')
                        with open(crd_info['crd_file'], 'r') as data:
                            body = yaml.load(data)
                    except IOError:
                        logger.error('Resource definition not in dir %s.',
                                     crd_info['crd_file'])
                    try:
                        await ext_api.create_custom_resource_definition(body)
                    except ApiException as exc:
                        logger.exception('%s update failed: %s', crd_info['kind'], exc)

    async def get_karmada_clusters(self):
        """
        Retrieve the clusters registered in Karmada, replicating 'kubectl get clusters'.

        :param kubeconfig_path: The path to the kubeconfig file.
        :return: A list of cluster names and their details.
        """
        try:
            # Load the kubeconfig file with the specified path
            await kubernetes_asyncio.config.load_kube_config(config_file=self.karmada_api_kubeconfig)

            # Create an API client for the Custom Resources API
            api_client = kubernetes_asyncio.client.CustomObjectsApi()

            # Query the 'clusters' custom resource in the 'clusters.karmada.io' API group
            group = "cluster.karmada.io"
            version = "v1alpha1"
            namespace = ""  # Clusters are cluster-scoped, no specific namespace
            plural = "clusters"

            response = await api_client.list_cluster_custom_object(
                group=group,
                version=version,
                plural=plural
            )

            # Process the response to extract cluster names and details
            clusters = []
            for item in response.get("items", []):
                clusters.append({
                    "name": item["metadata"]["name"],
                    "status": item.get("status", {}).get("conditions", "Unknown")
                })

            return_object = {}
            for cluster in clusters:
            # example
            # [{'name': 'uth-dev-cluster', 'status': [
            #     {'type': 'Ready', 'status': 'False', 'lastTransitionTime': '2025-04-07T10:24:31Z',
            #      'reason': 'ClusterNotReachable', 'message': 'cluster is not reachable'}]}, {'name': 'uth-prod-cluster',
            #                                                                                  'status': [
            #                                                                                      {'type': 'Ready',
            #                                                                                       'status': 'True',
            #  'lastTransitionTime': '2025-05-13T15:48:28Z',
            #  reason': 'ClusterReady',
            #  message': 'cluster is healthy and ready to accept workloads'}]}]
                return_object[cluster['name']] = cluster['status'][0]['status'] # true online, false offline
            return return_object

        except Exception as e:
            print(f"Error retrieving clusters: {e}")
            return []

    def apply_deployments(self, templates_dir: str, hostIP: str):
        """
        Read and apply Jinja2 YAML templates with multiple Kubernetes resources in a specific order.

        Args:
            templates_dir (str): Directory containing the YAML templates.
            hostIP (str): The host IP.
        """
        try:
            # Dynamically scan for all .yml and .yaml files
            template_files_path = glob(os.path.join(templates_dir, "**", "*.yml"), recursive=True) + \
                                  glob(os.path.join(templates_dir, "**", "*.yaml"), recursive=True)

            template_files = [os.path.basename(file) for file in template_files_path]

            if not template_files:
                logger.warning(f"No YAML templates found in directory: {templates_dir}")
                return

            logger.debug(f"Found {template_files} YAML templates in directory: {templates_dir}")

            # Load Jinja2 environment and YAML parser
            env = Environment(loader=FileSystemLoader(templates_dir))
            yaml = YAML(typ="safe")

            karmada_host_client = KubernetesLibrary()
            karmada_api_client = KubernetesLibrary(kubeconfig=self.karmada_api_kubeconfig)

            # Load Kubernetes configuration for the default environment
            # if 'KUBERNETES_PORT' in os.environ:
            #     config.load_incluster_config()
            # else:
            #     config.load_kube_config()
            #
            # # Initialize Kubernetes clients
            # apps_v1_api = client.AppsV1Api()  # For Deployments and DaemonSets
            # core_v1_api = client.CoreV1Api()  # For ConfigMaps, Services, PersistentVolumeClaims, etc.
            # Predefined order of resource kinds
            resource_order = ["configmap", "secret", "persistentvolumeclaim", "service", "deployment", "daemonset"]

            for template_file in template_files:
                logger.debug(f"Processing template: {template_file}")

                # Read and render the template
                template = env.get_template(template_file)
                rendered_template = template.render(hostIP=hostIP)

                # Parse the rendered YAML content
                parsed_resources = list(yaml.load_all(rendered_template))

                # Sort resources by predefined order
                sorted_resources = sorted(
                    parsed_resources,
                    key=lambda r: resource_order.index(r["kind"].lower())
                    if r["kind"].lower() in resource_order else len(resource_order)
                )

                for resource in sorted_resources:
                    if not resource:
                        continue  # Skip empty resources

                    kind = resource["kind"].lower()
                    namespace = resource["metadata"].get("namespace", "default")
                    name = resource["metadata"]["name"]

                    kubernetes_host_client = KubernetesLibrary()

                    try:
                        kubernetes_host_client.create_or_update(resource,name=name)

                        if kind == "configmap":
                            try:
                                core_v1_api.read_namespaced_config_map(name, namespace)
                                core_v1_api.replace_namespaced_config_map(
                                    name=name, namespace=namespace, body=resource
                                )
                                logger.info(f"Updated ConfigMap '{name}' in namespace '{namespace}'.")
                            except client.exceptions.ApiException as e:
                                if e.status == 404:
                                    core_v1_api.create_namespaced_config_map(namespace=namespace, body=resource)
                                    logger.info(f"Created ConfigMap '{name}' in namespace '{namespace}'.")
                                else:
                                    logger.error(f"Error updating ConfigMap '{name}' in namespace '{namespace}': {e}")

                        elif kind == "secret":
                            try:
                                core_v1_api.read_namespaced_secret(name, namespace)
                                core_v1_api.replace_namespaced_secret(
                                    name=name, namespace=namespace, body=resource
                                )
                                logger.info(f"Updated Secret '{name}' in namespace '{namespace}'.")
                            except client.exceptions.ApiException as e:
                                if e.status == 404:
                                    core_v1_api.create_namespaced_secret(namespace=namespace, body=resource)
                                    logger.info(f"Created Secret '{name}' in namespace '{namespace}'.")
                                else:
                                    raise

                        elif kind == "persistentvolumeclaim":
                            try:
                                core_v1_api.read_namespaced_persistent_volume_claim(name, namespace)
                                core_v1_api.replace_namespaced_persistent_volume_claim(
                                    name=name, namespace=namespace, body=resource
                                )
                                logger.info(f"Updated PersistentVolumeClaim '{name}' in namespace '{namespace}'.")
                            except client.exceptions.ApiException as e:
                                if e.status == 404:
                                    core_v1_api.create_namespaced_persistent_volume_claim(namespace=namespace, body=resource)
                                    logger.info(f"Created PersistentVolumeClaim '{name}' in namespace '{namespace}'.")
                                else:
                                    logger.error(f"Error updating PersistentVolumeClaim '{name}' in namespace '{namespace}': {e}")

                        elif kind == "service":

                            try:
                                core_v1_api.read_namespaced_service(name, namespace)
                                core_v1_api.replace_namespaced_service(
                                    name=name, namespace=namespace, body=resource
                                )
                                logger.info(f"Updated Service '{name}' in namespace '{namespace}'.")
                            except client.exceptions.ApiException as e:
                                if e.status == 404:
                                    core_v1_api.create_namespaced_service(namespace=namespace, body=resource)
                                    logger.info(f"Created Service '{name}' in namespace '{namespace}'.")
                                else:
                                    logger.error(f"Error updating Service '{name}' in namespace '{namespace}': {e}")

                        elif kind == "deployment":
                            try:
                                apps_v1_api.read_namespaced_deployment(name, namespace)
                                apps_v1_api.replace_namespaced_deployment(
                                    name=name, namespace=namespace, body=resource
                                )
                                logger.info(f"Updated Deployment '{name}' in namespace '{namespace}'.")
                            except client.exceptions.ApiException as e:
                                if e.status == 404:
                                    apps_v1_api.create_namespaced_deployment(namespace=namespace, body=resource)
                                    logger.info(f"Created Deployment '{name}' in namespace '{namespace}'.")
                                else:
                                    logger.error(f"Error updating Deployment '{name}' in namespace '{namespace}': {e}")
                        elif kind == "daemonset":
                            try:
                                apps_v1_api.read_namespaced_daemon_set(name, namespace)
                                apps_v1_api.replace_namespaced_daemon_set(
                                    name=name, namespace=namespace, body=resource
                                )
                                logger.info(f"Updated DaemonSet '{name}' in namespace '{namespace}'.")
                            except client.exceptions.ApiException as e:
                                if e.status == 404:
                                    apps_v1_api.create_namespaced_daemon_set(namespace=namespace, body=resource)
                                    logger.info(f"Created DaemonSet '{name}' in namespace '{namespace}'.")
                                else:
                                    logger.error(f"Error updating DaemonSet '{name}' in namespace '{namespace}': {e}")
                        else:
                            logger.warning(f"Unsupported resource kind: {kind}")

                    except Exception as e:
                        logger.error(f"Error applying resource '{name}' of kind '{kind}': {e}")
                        logger.error(traceback.format_exc())

        except Exception as e:
            logger.error(f"An error occurred during deployment: {e}")
            logger.error(traceback.format_exc())

    async def apply_namespace_to_karmada(self, resource_file: str):
        """
        Apply multiple Kubernetes resources (Namespaces, RBACs, etc.)
        from a YAML file to the Karmada cluster.

        Args:
            resource_file (str): The path to the YAML file containing the resources.

        Raises:
            FileNotFoundError: If the resource_file does not exist.
            ValueError: If a resource in YAML does not have a valid structure.
            ApiException: If there are issues communicating with the Karmada API or applying the resource.
        """
        try:
            # Load Karmada API configuration using the specified kubeconfig
            await kubernetes_asyncio.config.load_kube_config(config_file=self.karmada_api_kubeconfig)

            # Parse the YAML file to support multiple resource definitions
            yaml = YAML(typ='safe')
            with open(resource_file, 'r') as file:
                resources = list(yaml.load_all(file))  # Load all resources from the file

            if not resources:
                logger.warning(f"No resources found in file: {resource_file}")
                return

            logger.info(f"Processing {len(resources)} resources from file '{resource_file}'...")

            async with kubernetes_asyncio.client.ApiClient() as api_client:
                core_v1_api = kubernetes_asyncio.client.CoreV1Api(api_client)
                rbac_v1_api = kubernetes_asyncio.client.RbacAuthorizationV1Api(api_client)

                for resource in resources:
                    # Validate the resource
                    if not resource or "kind" not in resource:
                        logger.warning("Skipping an invalid or empty resource.")
                        continue

                    kind = resource["kind"]
                    metadata = resource.get("metadata", {})
                    name = metadata.get("name")
                    namespace = metadata.get("namespace", "default")  # Default namespace for namespaced resources

                    if not name:
                        logger.warning(f"Skipping resource of kind '{kind}' with no 'metadata.name'.")
                        continue

                    logger.info(f"Processing resource '{name}' of kind '{kind}'...")

                    try:
                        # Handle the resource based on its kind
                        if kind == "Namespace":
                            try:
                                # Check if the Namespace exists
                                existing_namespace = await core_v1_api.read_namespace(name=name)
                                logger.info(f"Namespace '{name}' exists. Updating...")
                                # Update the Namespace
                                await core_v1_api.replace_namespace(name=name, body=resource)
                                logger.info(f"Namespace '{name}' updated successfully.")
                            except ApiException as e:
                                if e.status == 404:
                                    logger.info(f"Namespace '{name}' not found. Creating...")
                                    # Create the Namespace
                                    await core_v1_api.create_namespace(body=resource)
                                    logger.info(f"Namespace '{name}' created successfully.")
                                else:
                                    raise

                        elif kind == "ServiceAccount":
                            # Handle ServiceAccount creation/update
                            try:
                                existing_sa = await core_v1_api.read_namespaced_service_account(name=name,
                                                                                                namespace=namespace)
                                logger.info(f"ServiceAccount '{name}' exists in namespace '{namespace}'. Updating...")
                                await core_v1_api.replace_namespaced_service_account(
                                    name=name, namespace=namespace, body=resource
                                )
                                logger.info(f"ServiceAccount '{name}' updated successfully.")
                            except ApiException as e:
                                if e.status == 404:
                                    logger.info(f"ServiceAccount '{name}' not found. Creating...")
                                    await core_v1_api.create_namespaced_service_account(namespace=namespace,
                                                                                        body=resource)
                                    logger.info(f"ServiceAccount '{name}' created successfully.")
                                else:
                                    raise

                        elif kind == "RoleBinding":
                            # Handle RoleBinding creation/update
                            try:
                                existing_rb = await rbac_v1_api.read_namespaced_role_binding(name=name,
                                                                                             namespace=namespace)
                                logger.info(f"RoleBinding '{name}' exists in namespace '{namespace}'. Updating...")
                                await rbac_v1_api.replace_namespaced_role_binding(
                                    name=name, namespace=namespace, body=resource
                                )
                                logger.info(f"RoleBinding '{name}' updated successfully.")
                            except ApiException as e:
                                if e.status == 404:
                                    logger.info(f"RoleBinding '{name}' not found. Creating...")
                                    await rbac_v1_api.create_namespaced_role_binding(namespace=namespace, body=resource)
                                    logger.info(f"RoleBinding '{name}' created successfully.")
                                else:
                                    raise

                        elif kind == "ClusterRole":
                            # Handle ClusterRole creation/update
                            try:
                                existing_cr = await rbac_v1_api.read_cluster_role(name=name)
                                logger.info(f"ClusterRole '{name}' exists. Updating...")
                                await rbac_v1_api.replace_cluster_role(
                                    name=name, body=resource
                                )
                                logger.info(f"ClusterRole '{name}' updated successfully.")
                            except ApiException as e:
                                if e.status == 404:
                                    logger.info(f"ClusterRole '{name}' not found. Creating...")
                                    await rbac_v1_api.create_cluster_role(body=resource)
                                    logger.info(f"ClusterRole '{name}' created successfully.")
                                else:
                                    raise

                        elif kind == "ClusterRoleBinding":
                            # Handle ClusterRoleBinding creation/update
                            try:
                                existing_crb = await rbac_v1_api.read_cluster_role_binding(name=name)
                                logger.info(f"ClusterRoleBinding '{name}' exists. Updating...")
                                await rbac_v1_api.replace_cluster_role_binding(
                                    name=name, body=resource
                                )
                                logger.info(f"ClusterRoleBinding '{name}' updated successfully.")
                            except ApiException as e:
                                if e.status == 404:
                                    logger.info(f"ClusterRoleBinding '{name}' not found. Creating...")
                                    await rbac_v1_api.create_cluster_role_binding(body=resource)
                                    logger.info(f"ClusterRoleBinding '{name}' created successfully.")
                                else:
                                    raise

                        else:
                            logger.warning(f"Unsupported resource kind '{kind}'. Skipping resource '{name}'.")
                            continue

                    except ApiException as e:
                        logger.error(f"API Exception while processing resource '{name}' of kind '{kind}': {e}")
                    except Exception as e:
                        logger.error(f"Unexpected error while processing resource '{name}' of kind '{kind}': {e}")

        except FileNotFoundError:
            logger.error(f"File not found: {resource_file}")
            raise
        except ValueError as e:
            logger.error(f"Invalid resource in YAML: {e}")
            raise
        except Exception as e:
            logger.error(f"An unexpected error occurred while applying resources from '{resource_file}': {e}")
            raise

    async def apply_rbac_to_karmada(self, resource_file: str):
        """
        Apply multiple Kubernetes resources (from a YAML file) to the Karmada control plane.

        Args:
            resource_file (str): Path to the YAML file containing the resources.

        Raises:
            FileNotFoundError: If the resource file is not found.
            ValueError: If a resource in the YAML file is missing required fields.
            ApiException: For API errors during resource application.
        """
        try:
            # Load the Karmada API configuration
            await kubernetes_asyncio.config.load_kube_config(config_file=self.karmada_api_kubeconfig)

            # Parse the YAML file
            yaml = YAML(typ='safe')
            with open(resource_file, 'r') as file:
                resources = list(yaml.load_all(file))  # Load multiple documents

            if not resources:
                logger.warning(f"No resources found in file: {resource_file}")
                return

            logger.info(f"Processing {len(resources)} resources from file: {resource_file}")

            async with kubernetes_asyncio.client.ApiClient() as api_client:
                core_v1_api = kubernetes_asyncio.client.CoreV1Api(api_client)
                rbac_v1_api = kubernetes_asyncio.client.RbacAuthorizationV1Api(api_client)

                for resource in resources:
                    if not resource or "kind" not in resource:
                        logger.warning("Skipping invalid or empty resource.")
                        continue

                    kind = resource["kind"]
                    metadata = resource.get("metadata", {})
                    name = metadata.get("name")
                    namespace = metadata.get("namespace", "default")  # Default for namespaced resources

                    if not name:
                        logger.error(f"Skipping resource of kind '{kind}' with missing 'metadata.name'.")
                        continue

                    logger.info(f"Processing resource '{name}' of kind '{kind}'...")

                    try:
                        # Handle each kind of resource dynamically
                        if kind == "ServiceAccount":
                            # ServiceAccount is namespace-scoped
                            try:
                                existing = await core_v1_api.read_namespaced_service_account(name, namespace)
                                logger.info(f"ServiceAccount '{name}' exists in namespace '{namespace}'. Updating...")
                                await core_v1_api.replace_namespaced_service_account(
                                    name=name, namespace=namespace, body=resource
                                )
                                logger.info(f"ServiceAccount '{name}' updated successfully.")
                            except ApiException as e:
                                if e.status == 404:
                                    logger.info(f"ServiceAccount '{name}' not found. Creating...")
                                    await core_v1_api.create_namespaced_service_account(namespace=namespace, body=resource)
                                    logger.info(f"ServiceAccount '{name}' created successfully.")
                                else:
                                    raise

                        elif kind == "RoleBinding":
                            # RoleBinding is namespace-scoped
                            try:
                                existing = await rbac_v1_api.read_namespaced_role_binding(name, namespace)
                                logger.info(f"RoleBinding '{name}' exists in namespace '{namespace}'. Updating...")
                                await rbac_v1_api.replace_namespaced_role_binding(
                                    name=name, namespace=namespace, body=resource
                                )
                                logger.info(f"RoleBinding '{name}' updated successfully.")
                            except ApiException as e:
                                if e.status == 404:
                                    logger.info(f"RoleBinding '{name}' not found. Creating...")
                                    await rbac_v1_api.create_namespaced_role_binding(namespace=namespace, body=resource)
                                    logger.info(f"RoleBinding '{name}' created successfully.")
                                else:
                                    raise

                        elif kind == "ClusterRole":
                            # ClusterRole is cluster-scoped
                            try:
                                existing = await rbac_v1_api.read_cluster_role(name)
                                logger.info(f"ClusterRole '{name}' exists. Updating...")
                                await rbac_v1_api.replace_cluster_role(name=name, body=resource)
                                logger.info(f"ClusterRole '{name}' updated successfully.")
                            except ApiException as e:
                                if e.status == 404:
                                    logger.info(f"ClusterRole '{name}' not found. Creating...")
                                    await rbac_v1_api.create_cluster_role(body=resource)
                                    logger.info(f"ClusterRole '{name}' created successfully.")
                                else:
                                    raise

                        elif kind == "ClusterRoleBinding":
                            # ClusterRoleBinding is cluster-scoped
                            try:
                                existing = await rbac_v1_api.read_cluster_role_binding(name)
                                logger.info(f"ClusterRoleBinding '{name}' exists. Updating...")
                                await rbac_v1_api.replace_cluster_role_binding(name=name, body=resource)
                                logger.info(f"ClusterRoleBinding '{name}' updated successfully.")
                            except ApiException as e:
                                if e.status == 404:
                                    logger.info(f"ClusterRoleBinding '{name}' not found. Creating...")
                                    await rbac_v1_api.create_cluster_role_binding(body=resource)
                                    logger.info(f"ClusterRoleBinding '{name}' created successfully.")
                                else:
                                    raise

                        else:
                            logger.warning(f"Unsupported resource kind: '{kind}'. Skipping resource '{name}'.")
                            continue

                    except ApiException as e:
                        logger.error(f"Error processing resource '{name}' of kind '{kind}': {e}")
                    except Exception as e:
                        logger.error(f"Unexpected error while processing resource '{name}': {e}")

        except FileNotFoundError:
            logger.error(f"Resource file '{resource_file}' not found.")
            raise
        except ValueError as e:
            logger.error(f"Invalid resource YAML: {e}")
            raise
        except Exception as e:
            logger.error(f"Unexpected error while applying resources from file '{resource_file}': {e}")
            raise


    def apply_agent(self, file_path: str,  hostIP: str, configmap_files: list = None):
        """
        Read and apply a Jinja2 YAML template with multiple Kubernetes resources in a specific order,
        and handle ConfigMap creation from multiple files if specified.

        Args:
            file_path (str): Path to the specific YAML file.
            hostIP (str): The host IP.
            configmap_files (list, optional): List of file paths for creating a ConfigMap
                                              (e.g., --from-file equivalent).
        """
        try:
            # Load Jinja2 environment and YAML parser
            env = Environment(loader=FileSystemLoader(os.path.dirname(file_path)))
            yaml = YAML(typ="safe")

            # Load Kubernetes configuration for the default environment
            if 'KUBERNETES_PORT' in os.environ:
                config.load_incluster_config()
            else:
                config.load_kube_config()

            # Initialize Kubernetes clients
            apps_v1_api = client.AppsV1Api()  # For Deployments and DaemonSets
            core_v1_api = client.CoreV1Api()  # For ConfigMaps, Services, etc.

            # Predefined order of resource kinds
            resource_order = ["configmap", "daemonset"]

            logger.debug(f"Processing template file: {file_path}")

            # Read and render the template
            template = env.get_template(os.path.basename(file_path))
            rendered_template = template.render(hostIP=hostIP)

            # Parse the rendered YAML content
            parsed_resources = list(yaml.load_all(rendered_template))

            # Sort resources by predefined order
            sorted_resources = sorted(
                parsed_resources,
                key=lambda r: resource_order.index(r["kind"].lower())
                if r["kind"].lower() in resource_order else len(resource_order)
            )

            # Process all resources
            for resource in sorted_resources:
                if not resource:
                    continue  # Skip empty resources

                kind = resource["kind"].lower()
                namespace = resource["metadata"].get("namespace", "default")
                name = resource["metadata"]["name"]

                try:
                    if kind == "configmap":
                        if configmap_files:  # Handle the case for creating ConfigMap from multiple files
                            logger.info(
                                f"Creating ConfigMap '{name}' in namespace '{namespace}' from files: {configmap_files}...")
                            self._create_configmap_from_files(core_v1_api, namespace, name, configmap_files)
                            logger.info(f"ConfigMap '{name}' created successfully from files.")
                        else:  # Handle ConfigMap from the YAML definition
                            try:
                                core_v1_api.read_namespaced_config_map(name, namespace)
                                core_v1_api.replace_namespaced_config_map(
                                    name=name, namespace=namespace, body=resource
                                )
                                logger.info(f"Updated ConfigMap '{name}' in namespace '{namespace}'.")
                            except client.exceptions.ApiException as e:
                                if e.status == 404:
                                    core_v1_api.create_namespaced_config_map(namespace=namespace, body=resource)
                                    logger.info(f"Created ConfigMap '{name}' in namespace '{namespace}'.")
                                else:
                                    logger.error(f"Error updating ConfigMap '{name}' in namespace '{namespace}': {e}")
                    elif kind == "daemonset":
                        try:
                            apps_v1_api.read_namespaced_daemon_set(name, namespace)
                            apps_v1_api.replace_namespaced_daemon_set(
                                name=name, namespace=namespace, body=resource
                            )
                            logger.info(f"Updated DaemonSet '{name}' in namespace '{namespace}'.")
                        except client.exceptions.ApiException as e:
                            if e.status == 404:
                                apps_v1_api.create_namespaced_daemon_set(namespace=namespace, body=resource)
                                logger.info(f"Created DaemonSet '{name}' in namespace '{namespace}'.")
                            else:
                                logger.error(f"Error updating DaemonSet '{name}' in namespace '{namespace}': {e}")
                    else:
                        logger.warning(f"Unsupported resource kind: {kind}")

                except Exception as e:
                    logger.error(f"Error applying resource '{name}' of kind '{kind}': {e}")
                    logger.error(traceback.format_exc())

        except Exception as e:
            logger.error(f"An error occurred during deployment: {e}")
            logger.error(traceback.format_exc())


    def _create_configmap_from_files(self, core_v1_api, namespace: str, name: str, file_paths: list):
        """
        Helper function to create a ConfigMap from multiple files
        (similar to kubectl create configmap --from-file=...).

        Args:
            core_v1_api: CoreV1Api instance.
            namespace (str): Namespace to create the ConfigMap in.
            name (str): Name of the ConfigMap.
            file_paths (list): List of file paths to use for the ConfigMap data.

        Raises:
            FileNotFoundError: If one or more provided file paths do not exist.
        """
        try:
            data = {}

            # Iterate over file paths and read their contents
            for path in file_paths:
                if not os.path.isfile(path):
                    raise FileNotFoundError(f"File not found: {path}")
                with open(path, 'r') as file:
                    data[os.path.basename(path)] = file.read()

            # Create the ConfigMap body
            config_map_body = {
                "apiVersion": "v1",
                "kind": "ConfigMap",
                "metadata": {
                    "name": name,
                    "namespace": namespace
                },
                "data": data
            }

            try:
                # Check if the ConfigMap exists
                core_v1_api.read_namespaced_config_map(name, namespace)
                # If exists, replace it
                core_v1_api.replace_namespaced_config_map(name=name, namespace=namespace, body=config_map_body)
                logger.info(f"Replaced ConfigMap '{name}' in namespace '{namespace}'.")
            except client.exceptions.ApiException as e:
                if e.status == 404:
                    # If not exists, create it
                    core_v1_api.create_namespaced_config_map(namespace=namespace, body=config_map_body)
                    logger.info(f"Created ConfigMap '{name}' in namespace '{namespace}'.")
                else:
                    logger.error(f"Error managing ConfigMap '{name}' in namespace '{namespace}': {e}")

        except Exception as e:
            logger.error(f"Error creating ConfigMap from files '{file_paths}': {e}")
            logger.error(traceback.format_exc())

    async def apply_system_description(self):
        """
       Iterate over YAML files in the directory, add the `kind` and `apiVersion` keys
       (if necessary), and apply each file to Karmada.
       """
        for filename in os.listdir(self.directory):
            if not filename.endswith((".yml", ".yaml")):
                continue  # Skip non-YAML files
            logger.debug(f"----------------- reading system desc {filename}")
            file_path = os.path.join(self.directory, filename)
            try:
                with open(file_path, 'r') as file:
                    yaml_content = self.yaml_parser.load(file)

                if not isinstance(yaml_content, dict):
                    logger.error(f"Invalid YAML structure in file '{filename}'. Skipping...")
                    continue

                # Determine the `kind` and add necessary headers
                highest_key = list(yaml_content.keys())[0]
                if highest_key == "MLSysOpsNode":
                    kind = "MLSysOpsNode"
                    name = yaml_content[highest_key]["name"]
                    cluster_id = yaml_content[highest_key]["clusterID"]

                elif highest_key == "MLSysOpsCluster":
                    kind = "MLSysOpsCluster"
                    name = yaml_content[highest_key]["cluster_id"]
                    cluster_id = yaml_content[highest_key]["cluster_id"]
                else:
                    logger.warning(f"File '{filename}' does not contain MLSysOpsNode or MLSysOpsCluster. Skipping...")
                    continue


                # Add mandatory headers (kind and apiVersion)
                yaml_content[highest_key]["apiVersion"] = "mlsysops.eu/v1"
                yaml_content[highest_key]["kind"] = kind
                yaml_content[highest_key]["metadata"] = {
                    "name": name,
                    "labels": {"clusterId": cluster_id}}

                self.create_and_apply_policy(cluster_id,name)

                # Apply the enriched YAML to Karmada
                self.apply_yaml_to_karmada("mlsysops.eu","v1","default",yaml_content[highest_key])


            except Exception as e:
                logger.error(f"Error processing file '{filename}': {e}")
                logger.error(traceback.format_exc())

    def apply_yaml_to_karmada(self, group, version, namespace, yaml_content):
        """
        Apply the given YAML content to Karmada using the Karmada API.

        Args:
            yaml_content (dict): YAML content to apply.

        Raises:
            ApiException: If an API error occurs while applying the YAML content.
        """
        try:
            # Determine the namespace (if any) and the kind
            metadata = yaml_content.get("metadata", {})
            namespace = metadata.get("namespace", "default")
            kind = yaml_content["kind"]

            logger.debug(f"Applying {kind} to namespace '{namespace}' {yaml_content}")
            # Determine the appropriate Karmada API call
            if kind in ["MLSysOpsNode", "MLSysOpsCluster"]:
                config.load_kube_config(config_file=self.karmada_api_kubeconfig)

                # Use CustomObjects API to apply the resource to Karmada
                core_v1_api = client.CustomObjectsApi()

                core_v1_api.create_namespaced_custom_object(
                    group=group,
                    version=version,
                    namespace=namespace,
                    plural=kind.lower() + "s",
                    body=yaml_content,
                )
                logger.info(f"{kind} '{metadata.get('name', 'unknown')}' applied to Karmada.")
            else:
                logger.warning(f"Unsupported kind '{kind}'. Skipping application to Karmada.")
        except ApiException as e:
            logger.error(f"Failed to apply kind '{yaml_content['kind']}' to Karmada: {e}")

    def create_and_apply_policy(self, cluster_id, name):
        """
        Create and apply a PropagationPolicy for the clusterID.

        Args:
            cluster_id (str): The cluster ID to use in the PropagationPolicy.
        """
        # Define the PropagationPolicy structure
        env = Environment(loader=FileSystemLoader("templates/karmada-propagation-policies"))
        yaml = YAML(typ="safe")

        # Read and render the template
        template = env.get_template("system-description-policy.yaml.j2")
        rendered_template = template.render(clusterId=cluster_id,name=name)
        policy = yaml.load(rendered_template)

        try:
            config.load_kube_config(config_file=self.karmada_api_kubeconfig)

            core_v1_api = client.CustomObjectsApi()  # For ConfigMaps, Services, etc.
            logger.debug(f"Creating policy {policy}")
            # Apply the PropagationPolicy using Karmada API
            core_v1_api.create_namespaced_custom_object(
                group="policy.karmada.io",
                version="v1alpha1",
                namespace="default",
                plural="propagationpolicies",
                body=policy,
            )
            logger.info(f"PropagationPolicy '{policy['metadata']['name']}' successfully applied for cluster '{cluster_id}'.")

        except kubernetes.client.rest.ApiException as e:
            logger.error(f"Failed to apply PropagationPolicy for clusterID '{cluster_id}': {e}")
